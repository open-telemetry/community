# OTel in Practice Presents: Context, Abstraction, &amp; Threading the Needle with Hazel Weakly

Published on 2023-09-16T04:37:50Z

## Description

Join Hazel Weakly for this thoughtful discussion on Observability, distributed tracing, and various challenges associated with ...

URL: https://www.youtube.com/watch?v=1a7GyarlGAQ

## Summary

In this YouTube video, Hazel, who is involved in innovation and developer experience at her company and also serves on a hospital foundation board, presents a detailed discussion on observability, context abstraction, and the challenges associated with distributed tracing and OpenTelemetry. The talk explores the definitions of observability, emphasizing the importance of asking meaningful questions to derive useful insights from systems. Hazel outlines the components of context and how they relate to observability, discussing various types of context, including in-process and cross-process context, and the complexities of manual instrumentation. She highlights challenges such as the lifecycle of traces, context management, and the issues that arise when trying to abstract these concepts in a distributed system. The presentation concludes with a call for collaboration and a deeper understanding of these technical challenges, inviting further discussion and sharing of knowledge in the observability community. The video includes interactions with participants who express appreciation for Hazel's clear explanations and raise questions about post-processing in telemetry data.

# Observability and Context Abstraction

I am having a lot of fun hoping to run Innovation and developer experience in my current company. I also serve on the board of directors of the hospital foundation and have a lot of opinions online. You can find me pretty much everywhere, and I am really excited to be here today to talk about context abstraction and threading the needle. 

## Introduction to Observability

I'm going to give a primer on observability and discuss how I think about it in the context of historical necessity. We'll talk about why we need distribution and how that ties into observability. Additionally, we'll explore some components of social filtration, mainly context, and abstraction. One of the difficulties you may encounter when trying to build libraries or a platform team is moving beyond manually instrumenting all your code and writing everything from scratch. 

### Starting with Observability

When you start with observability, you have your entire system, and you want to figure out what’s going on. Over time, different groups have defined observability in various ways. One definition comes from consumer theory and states that it's the ability to measure the internal state of a system based on its external outputs. This is a great definition, but it doesn't tell the whole story.

Another definition originates from cognitive systems engineering, which describes observability as feedback that provides insight into processes and the work required to derive meaning from available data. I appreciate this definition because it emphasizes that observability is a dialogue. You need to know not just how to observe everything but also how to reach that point and what it means.

### My Personal Definition of Observability

My personal definition blends the two previous definitions: observability is the process through which one develops the ability to ask meaningful questions and receive useful answers. This definition is important because it highlights that observability evolves over time. It may mean something different today than it does tomorrow.

Meaningful questions are crucial to observability. These questions may or may not involve computers or people, and they should be significant to your business. For example, if a CEO wants to know how the company stands in the market and how feasible it is to reach a desired position, that is a meaningful question that an observable system can help answer.

For engineers, observability often revolves around questions about the system and code. We should all collaborate to solve these problems and find answers together. 

## Context and Abstraction

Context plays a significant role in observability. The documentation for OpenTelemetry states that context is a propagation mechanism that carries execution state values across API boundaries and between logically associated execution units. This is essential for understanding how to instrument and use context effectively.

When you instrument your code, you will typically create spans that contain context information. Each span will have identifiers such as span ID and trace ID. You can think of traces as graphs, where spans are nodes and links are edges. However, managing these links can be challenging. 

### Types of Context

There are different types of context to consider:

1. **In-Process Context**: This is standard and handled automatically by the library or SDK. You typically don't need to think about it unless you explicitly need to manage links between spans.
   
2. **Cross-Process Context**: Involves serializing context and attaching it to payloads during inter-service communication. This can be set up to ensure that the context flows seamlessly between services.

3. **Baggage**: This allows you to carry values downstream but is typically viewed as a questionable practice. It can be powerful but should be used sparingly.

### Challenges with Context

When working with context, you may face challenges. For instance, once a span has ended, you cannot add information to it. This limitation can lead to issues where adding information after the fact becomes impossible or inconvenient.

Additionally, if you want to build reusable abstractions, you may encounter difficulties due to the need for cross-cutting concerns. For example, if you want to collapse spans or manipulate the graph of spans, it can be challenging to do so effectively.

## Conclusion

To sum up, observability is the process of developing the ability to ask meaningful questions and obtain useful answers. The more you can observe your system, the more correlations you can infer from your data. However, be cautious—just because you can find the needle doesn't mean you need to build a haystack. 

Context is the glue that turns disparate data points into a unified trace. Understanding how to use context effectively can enhance your observability efforts. Observability and abstraction can sometimes be at odds, creating challenges in how you instrument your systems and collaborate with others. 

Thank you for your attention today, and I'm open to any questions you might have!

## Raw YouTube Transcript

foreign [Music] [Music] I am having a lot of fun hoping to run Innovation and developer experience in my current company I also serve on the board of directors of the hospital foundation and I have a lot of opinions online you can find me pretty much everywhere and I am really excited to be here today talking about contact abstraction and typing the needle so I'm gonna go over kind of like a primer of observability and talk to you a little bit about how I think about it and sort of what that contest is and the historical why do we need distributation and how does that tie into observability and then we're going to talk about some components of the social filtration mainly context and then we're going to talk about abstraction and one of the difficulties that you can run into when you're trying to actually in real life build down libraries or build on platform team or build out something other than just manually instrumenting all of your code and writing everything from scratch don't you started with observability you have essentially you have your system you have everything and you want to figure out what's going on and over time people have run into this problem and different groups of people have come up with different definitions for observability so one definition that you've heard Journey majors and a lot of other people um open Telemetry and tracing backgrounds and distribution system background to talk about is the one from consumer Theory and that is the ability to measure the internal state of a system based on its external objects and so this is a definition that you see repeated in a lot of places it's a great definition I like it a lot um but it isn't necessarily the entire story um one other definition comes from a different theory of practice which is cognitive systems engineering and so for them their definition is feedback that provides insight into process and the work required to start to meaning from available data so we like this definition for a lot of reasons mainly that it does a really good job at showing that you that observability is really this back and forth dialogue you need to not just have you know oh you can observe everything well that's cool once everything's built out but like how do you get there what does it mean and the whole process of people are involved too is something that this definition kind of highlights and I love any technical definition that includes people it's my favorite Mr speaking of which my personal definition is I'm not biased but I like listen the most um and this one is I took the other two definitions from cognitive systems and from Contour Theory they're kind of blending them together and so for me my definition of observability is the process through which one develops the ability to ask me equal questions and again useful answers so the way I think about that is it's a process which means it has to be evolved and you start from somewhere but you're not going to stay there you're going to continually figure out what observability means to you and it may mean something different today than it does tomorrow then it will not show you than it did last week and then additionally meaningful questions is really the thing that observability to me hinges around can you ask a meaningful question of your system which may or may not involve computers may or may not around people it may involve like a whole bunch of different things and are those questions meaningful to business meaningful to you meaningful to what you need out of that learning and in asking those questions can you get a useful answer so I like this definition for me because it includes every aspect of observability in my opinion like if a CEO wants to say hey I have this meaningful question which is I want to know where we are in the market compared to where we want to be in the market and how feasible am I going to get there can they answer that to build like what we need in order to approach our problems for the next five years I only said in Los Angeles so I'm keeping them happy and healthy that's a meaningful question an observable system will let you answer that and for engineers a lot of that observability questions it's going to come down to things about the system things about code and we're going to dig a lot more into that today than the other questions and we should all be working together and we should all be able to collaborate in order to actually solve all these problems into these answers so for me a meaningful question is one that maximizes how much you learn about the system that you're participating in to like if you have that system and you want to know more about it what does that mean how do you get there what are you doing right so for programming we have all my camera disappeared brilliant some I love silent problems all right so I'm going to figure out what happened there super briefly and then fix that and then get back and if I can't fix it then I'll just tell everyone what's on the slide um oh well all right let me share my screen again and I'll just tell you what was on the slide sorry about that I debugged everything and we're learning information awesome so imagine on the slide that you have a typical system in which you have someone and they're running a web shiver and they are asking themselves what is this web server doing and should they look at the ones and the lots and once you have no data whatsoever absolutely nothing nothing's there and they're like okay now what um what do I do back in the good old days well you probably would have done was you would have just killed production taking the whole thing down launched the debugger and just steps through the entire system step by step and solving everything you can ask a lot of meaningful questions that way and it can get a lot of useful answers everything's solved and all you had to do is completely change production in order to do it which is you know maybe not maybe not the best approach but it is you know it's in votes that's what we did for a long time and in many ways it still works but one of you have to constraint of to I want to observe without interruption I want to you know keep everything running and ask me to focus into the system and now I'm considering the system running as part of that question so let me try you know adding some French statements which again we're seeing a little bit of lack of observability here in the slides that's fine so if we have a French statement and we've added them everywhere and we now have a real login this is awesome so you can imagine us taking the web server and getting those alarms and looking through and you can see oh hey this one usually locked in this one um I use a middle transaction they're able to do something and then they locked out that's awesome we have everything there we have it done and we're ready to go right is everything is everything there well so you have the web server and you have the back end and unless you have very carefully you know done everything with your logging you'll notice that the front end and the back end nothing's tied together the pen and might say oh you should check down use your uh in the back end might say this database middle transaction this little visual transaction this individual transaction and you have nothing to tie those two disparate pieces of information together to like okay I still can't really understand anything about the system I know when each individual piece is doing but I have nothing to tie it all together contest it really ties the system together so contest in an open Telemetry is for class cutting concerns the documentation for open Telemetry they say that context is a propagation mechanism which carries execution script values across API boundaries and between logically Associated execution units and that is awesome let's break that down just a tiny bit so contest let's skip on the middle bit carries values contest is the blue the terms of macadata into unified trees so what does that mean for you what does that mean but it's just um what does that mean when you're trying to understand it and instrument it so let's break down and decent contest they're going to have for each span they're going to have a whole bunch of context in there you'll have like this fan ID which identifies that the trace ID some Trace flies and a train state they're going to have essentially everything that identifies to spam of which there are many spans in one trace and many traces in one system scan links or another type of context and they say hey this Advantage related to Market so you can think of traces as a graph expands or nodes and then links to the edges so if you have a graph that's a tree and you're like sort of building it down and all of a sudden you need to take this one span over here and it's one span over here and to say but they're kind of links together you build that link and that's an edge in that graph Lynch can be really confusing they can be kind of weird they're not always integrated very well in the whole setup but they are needed for especially in some types and patterns and they are what turn open Telemetry traces from a tree into a graph and so they're the most expensive thing you have in there and also the hardest thing to work with at the same time So currently you can only add them at span pretty soon time but people want to be able to add them anytime and that may happen in the future does you'll be able to have a non-directed graph and a little drag which will be fascinating another type of context is baggage packets want to keep valued parents Downstream it is widely regarded as a questionable thing to use I know many people who might banned it in their code base it's a bit of a on but also very very powerful and flexible it is one of the ways to send information Downstream but you still can't use it to send information upstream and I'll get more into what I mean by that later um the package is there you may eventually need it I kind of hope you don't but it's there and when you have it so when you have all these different types of context and you have these different services and you have the different processes how do you take this contest and actually use it to glue together everything and make it usable you have the in-process contest and then you have the class process and how to complicate things from one thing to another and then you have fun process which is in everything in and actually taking it in the next service and going down that way so I'm going to go over all of them in order so there's some code here sorry about that um I've never even probably known as contest in process it's the normal context it's very typical very standard and this is what you've seen the documentation this is the in process contest you create an octaves fan and then in that disadvantages and work you create another active span and then that context and links the two actually happens pretty much automatically and you never really need to think about it the library and the SDK will handle all of that for you sometimes however you do need to add it explicitly um and this is a invisible example showing you that you need to do it especially one comes to um making links and doing things that way I'm going to one second oh amazing I'm going to watch my screen shoot uh stop sharing and then share something different it turns out I accidentally made my syntax highlight and only work in Firefox that's what that was cool yay there you go you can see here that we have the current span we have these fan contents and we get that context and pull it out manually so then we can create a span with a link we need to do that in order to propagate things manually for this type of context information but typically you don't really need to do that and things through it just naturally words with the links you need to do normally to that that can be a little tricky blush process there's two steps involved you serialize the context foreign it can actually secretly don't tell anyone I told you this but there's no reason context needs to be an adder you can do anything with any transform mechanism that you want to it's just really serializing the context needs to happen somewhere and then that needs to be attached to the payload of your call so I know some people who have actually serialized the context and embedded it into an RPC account as a way of actually instrumenting and tracing embedded systems um some people have done that with their own bootloaders which is actually really cool um it doesn't need to be a matter a little wild if you want to use the library should not write everything yourself down all the open television stuff will stick it in each TV header for you so what that looks like is you have from the sending service the sending service is going to inject what's the publication object the current context into some output and so that will do the serialization process and then you'll have a transparent and a tree State and then output and you can use that over the internet the transparent is actually the only thing that you need the Twisted has a bunch of other stuff but you don't actually kneel in and you may not want it so the transparent is the trace ID and everything required to actually link the span from the net system over the trace state has on the other fun goodies that you may want but may not want some people I know have been using twisted and can't touch specification because of issues it has then I'll get to later the context one process this is the second process we've yielded everything up on the internet and now I'm ready to receive that and actually integrate it you'll have you get the fabricator you ingest everything and you deserialize the contacts and you extract it and then you did that it's not a context and you make it your current contest you don't need to make it the current content but typically that's what people do um sometimes people use the trace state in order to determine whether or not they should make the contents the current context and you can maybe want to do that sometimes if you don't always own your systems end to end and someone may be putting something in the middle somewhere um that can be really tricky I know that some open Telemetry vendors for example have run into this problem of you need to really make sure that you're contacted your contacts before actually making it your current contest um so that's a lot of fun and then once you have that context then you've started it you set your span and just done working from there so that is moving the context wrapping everything together and you have all of that and that is great but that is all really about manual instrumentation that assumes that at every single point in every service you are writing all of your code you're writing all of your instrumentation you're writing everything from scratch and you're writing it right there in line with all the code in an intrusive manner if you don't want that intrusive style and you want to be able to build something for other people to use this is where you'd like to run into a lot of problems and we'll get into this now this is in my opinion one of the weakest aspects of fishing in general and it's a sign of the image journey in the ecosystem I'm gonna have a lot of hope that can be improved and I'm looking forward to seeing what happens there do you remember earlier when I said that context is about to cause any concerns when they have a cross Canadian concern and you tie everything together what you also have is cross-cutting breakage because um one of my favorite um launch out there is Hiram's law which tells them with a sufficient number of users of an API it does not matter what you promise in the contact all observable behaviors of your system will be dependent on by someone which means that the more instrumentation that you add into your system the more things that you're adding that can be observed by yourself but also the rest of the system and so paradoxally when you come on service boundaries in theory you can only depend on the public API and service it's a very standard service oriented architecture and things like that the tracing actually doesn't do that it's out of hand intentionally invisible not apparently API and if you've been with anything anywhere it'll propagate to the rest of the system and you'll end up having a lot of essentially convention and hand holding and little manual pieces put together that will break every time you change something to those out of band information become in band semantics and this problem is something that you see in a lot of different ways more open Telemetry it's actually specifically about this context modification but in form of verification you see this in terms of the internal implementation details of a function changing the proof required to show the scratch verified for property and in distributed systems you can see this in the end-to-end property of networks and in lots of other places you can see it probably one of the easiest ones is different agility of snapshot testing for fun and Design Systems if you've ever worked on those you know that you can meet the tiniest little change everything's the worst and somehow you just broke your entire test Suite because some lines moved here and there in the code itself or something changed here and there in the code itself or in like the HTML but the actual appearance and everything's fine and you end up dealing with this frustration and description of the out-of-man information becoming in man to mantis and that mismatch causing wreckage and so in open telemetry package is not simple enough to cost a lot of honey it's abused one context is key and when you have this uh class process propagation you lose the ability to have your out of band and inbound to mantis match up and be enforced across boundaries additionally in Winter designing options or you're wrapping them that same Alabama information will be very painful because you can't necessarily build anything that actually lets you do this in a reusable way unless you build a shared library of semantic conventions and speaking of which a good options are both transparent and opaque what I mean by that is they're transparent in that you don't have to know that they're there any condition about them at that level of abstraction it's a good way to think about that is for example HTTP requests they just happen and they're just there and you don't really have to know that they're implemented on top of a bunch of wire or glue terrible crimes and weird packet header loss information blah blah blah um there's a lot of trauma behind that but you don't you have to know that with that said you can't know that and the transparency there is that you can reason about everything at that level as if the abstin was in there and you can write things that are aware of the fact that they actually work through it in order to know and understand the underlying system to having that absorption means that you don't need to know the system underneath it but that the system underneath it doesn't make it less understandable of inflammatory and out-of-band information in general meets both of those goals hard to achieve the Louisiana ban information is not actually semantically embedded in the system and becomes relevant to the system and so you can't build an abstraction that lets you operate without knowing the internal implementation details and you don't actually have a way to observe the internal implementation details and know what they are without disapproved forms memorizing those conventions and so that gives you this quandary uh what do you do with that and this can manifest in a couple interesting ways um but a different problem of abstraction is I'll show you this one and this is problem that I run into the most which is what I call it the life cycle problem and that is you have tracing which is a graph but you don't actually have a way to really manipulate the graph very well and that shows up in two ways the livestock of how much the first flame which is that sending information up a graph or back in time so to speak isn't super possible or convenient or really ergonomic in any way and then adding then and then adding things after the fact is not possible either so you can't like pack to things as a girl and like incrementally build up or out of Beyond build up a view of the graph that's more complete so here's an example we have a web server a service and a client and so the web server has you know one event a once fan and then a second span two fish has one span and then a plan has one span and they have overlapping timelines there's problems that I ran into trying to deal with building this so the first Span in the web server can pass information to the second span when creating it that's totally fine that works that's amazing that's awesome however it has no real way to pass information to the second span after creating it so after you've created that a challenge fan the um root doesn't really have any way to continue to add information it doesn't have any way to modify that and doesn't have any way to like dig down into the tree and continue to add things if you have intuitively instruments and everything you do have the reference to this fan and the theory you can work with it one of your building apps into new building libraries you don't have that so you don't have a way to send information down they have baggage but it almost feels like a workaround it doesn't feel like it's embedded in this idea of how do I add things into the system and build this graph conversely the challenge man doesn't have any good way to send information to the parents fan conveniently at all it's possible if you know how to do it it's possible if you know how to build and work around for that you can even build conventions to make it easier but it's not absolutely convenient in any way the lump server is able to pass information to the service and then the client via contact configuration which I talked about earlier and that's possible not to create Networks however the service and the client essentially have no way to pass any information back up to the web server there's test that's not happening forget about it another thing that's interesting here is if you notice the life cycle of the web server watched is actually shorter than the life cycle of the whole trees which means that Toyota sampling is not going to work as you might expect till sampling really wants you to have a full Stitch treat with a scooped corn snack life cycle to the web server or the root span has to be the longest span and everything else has to be inside of it and organized nicely so that you can make a decision once you've collected everything and when you have these Instagram timelines and you don't actually know how long everything is going to be if you don't know how long to wait to make your final decision and you end up discussing until it becomes heuristic faced rather than oh and let's actually do things but you can really really bring you if those heuristics are used as part of filtering your traces and actually trying to sample things so Taylor sampling Distributing choices is actually really really hard um another problem is that once each fan has ended you have no way to add information to it so even though it is technically possible to try and add information to expand from the parent you can add a permission to a challenge fan in some ways that only works if the child span hasn't ended yet and you have no way to know one or not adding that information worked she can end up with code then adds information to expand works great more Express Financial production it's awesome and then someone optimizes the John function I mean it should take half the time and used to and then everything starts breaking silently because you didn't actually know then now you're trying to add things to his fan after it ended you can have a really weird and Rich conditions essentially um speaking of that also happens um yeah she can add information to the service and also the child and parents have the same problem to even in context and uh even in process versus Under severe process you still run into the same issue which means that you have a ton of internal implementation details of the instrumentation the shape of the code how the code works the life cycle of their code the column staff of everything to keep track of which if you are the engineer writing everything interviewing with the whole system and working end to end with it that may not be a huge deal for you and that may actually be there that's one of the reasons why open to my materials so deeply in hand with people owning their systems end to end and having that feedback there's actually in some ways available compensation because you can't build an abstraction unless a lot of people work on top of that so you have to own your system end to end intrusively rather than being able to build these abstracts attention let you instrument things more effectively the second problem there that you run into a lot is what I call the graph rewriting problem so we dig back into this livestock problem you have a bunch of information based on life cycle so when you make lesbians lens fans and and how that interfaces with the constant of the the stimulate system in general need graph rewriting problem is this one the rule of thumb when doing instrumentation is that you have like this final instrumentation that can build this scaffolding uh you would take all of your manual instrumentation and hang it on that so in theory you're not really creating one spans your usual understands that auto instrumentation already set up and you're just adding attributes in my spots which sometimes that doesn't work especially when you're trying to write abstract code you end up wanting to create this fan only abstract couldn't do that but in general the more you can just add attributes to an existing span created by Honor instrumentation but not sad where do libraries go in this and how do they work and how do you actually do this so let's look at this as an example we have a um tree uh it's fast client and then It smash client has some action someone called make request on the client side and then the auto instrumentation has that git endpoint the next step on the client side to half the function call and then you have the honor instrumentation of the actual that response awesome that's great that's cool then we go over into the server and the server has the server endpoint that has three manaway functions that it has a post endpoint uh for the sending uh for an internal call then that has the same chain uh you post on one thing and then you go to the next one then you keep going and keep going and keep going and you can run into the same middleware and you're going to do all that so if you're going to run into a couple problems here the first problem is how do you collapse spans you don't actually have a good one to do that what if I don't actually want all of the middleware to be their own spans and I want to have just one span for everything just add information the development to it with attributes as I go down to me if you want some spam Events maybe I just want the attributes maybe I want things like that and I don't actually need this fan for like the middleware around or maybe I don't need a fan for some other things I don't have a way to like collapse that tree down and that can be is activated by the Fall that's that if you want to search through your system typically the root span is where you search or the same level of a span is when you search when you're trying to like index through your data and so if you have dealer at different span levels you essentially you have no way to correlate those two pieces of datum and do a query in which you aggregate things across those spans so that's one reason why a lot of good practice is to have very very wide events and a very wide spans and less of them so that way you have all the data at the same level and you can do all the correlation and grouping and aggregation and everything else there that you need to in order to effectively look through your data and find something but if you have all of your instrumentation and your honor instrumentation building a nested tree of like 10 or 20 inch fans before yeah as you get to run any of your code where do you stick in so that it's at the level that it needs to be and then on top of that every Library Auto instrumentation um and things like that reinvent their weird set of configuration I want you to try and make it to that they can help solve some of these problems so you'll have um if you look through all the sdks or all the contributors contributing libraries for open Telemetry you'll notice this problem over and over you're like oh how do I use for example the express um server Auto instrumentation it'll save you can just use it and also here's like 15 different options do you want to silence some endpoints do you want to filter some endpoints do you want to silence submit awareness do you want to whatever here's a whole bunch of functions you can use here's some callbacks and we're going to call this compact before and after this we're going to call these to these endpoints and essentially it gives you every possible hook point to you can think of to enter into system and stick your own code there as if you haven't written it yourself but when you don't have this way to write an abstraction and you end up having to sit there and write the code yourself in all these intuition endpoints and you need to have people have having foresight in their libraries to put these uh insertion points for you you have this very very weird platform of really people want to like more or less patch the source to go to the libraries and the other instrumentation and they want to have written all of it themselves graph effectively why can't we deal with that right what's going on I think I cut out for a brief second there did everyone catch the last things that I said awesome so in conclusion there are some problems here there are a lot of things going on there's some advice on what to do and I'm gonna go through all of that now to observability is the process through which one develops the ability to ask meaningful questions and get useful answers meaningful questions for you are going to be about learning about the system how do you collectively get together and Advance your understanding of the system Its Behavior how it interacts with you and everything and how do you get that knowledge as quickly as possible those are meaningful questions continue can use for answers from them if you can your system is becoming observable however observability is interesting because the more you can observe the more correlations you're going to infer with your data and the harder it's going to be to discover contributing factors so just because you can find needle it doesn't mean you need to build a haystack and when you have more and more data and you keep shoving more things in there then you have more and more out of band data and you just add more and more layers of things they can give you observing money into the system you should be really careful to look at everything and go is this actually an intervention or understanding of the system or is this adding noise contacts to contest plus configuration is traces is the glue that turns and back of data points into a unified Trace when working with context it interfaces with everything that has to do with open Telemetry and in many ways remains invisible the entire time using until you're wondering where the entire or how to use it or maybe you're confused but if you know how to use context and know what to think about when using contest it can become your friend one way to map contacts and map different like aspects of open Telemetry together is thinking about the shape of those contacts of those Concepts so traces are a graph expand your nodes and links your edges despite choices being a graph they're often actually mostly thought of and best most ergonomically designed as a cardstock which is a training that is like perhaps multi-branched and that tree is very uh scooped in the top node is always the whitest and the longest and everything is only encapsulated all the way down and that's the most natural and ergonomic way to do open Telemetry and tracing and everything's going to push you towards that but traces are a graph and you can actually access all of that graph power when you need it and sometimes you wish you didn't observability and abstraction are natural enemies they are the chief people in high school that love to take in on each other the entire time they're doing everything and so even though we love open Telemetry and we love observability and we love my other sister meditation the problem of needing a large amount of out-of-band context but also wanting the ability to add and annotate a very complicated problem of your entire system it's business Logic the flow of information throughout the system those are all problems that we don't actually have good answers for in general we don't have good leverage for that we don't have good approaches for that and then it stands Beyond open Telemetry and Beyond observability this is just one of those ways that it becomes a very very obvious problem and two ways of having an average problem are the life cycle problem which we talked about which is where you have this graph you have the whole power of a graph where you don't have a graph that is like convergent you have a graph that you kind of have the satanically know the shape of an Azure building out and you can't really patch it up and picture them later and speaking of that graph reminding it is really difficult if not impossible it's very much convention and ad hoc based there you are does anyone have any questions thoughts or anything else I just want to say hazel that the way that you uh describe these Concepts in in uh distributed tracing and open Telemetry are like I think the clearest I've heard um so thank you for that I I definitely really appreciate that I I think it's uh it's like every everything now like just fully makes sense so yeah I just want to Echo that but that's that's definitely the vibe it's like oh yeah cool now I know what I'm writing about for the next six months it's like the stuff that the stuff that Hazel has put so clearly it's very good really happy to hear that the the question that I had is I'm I'm curious how you feel like um like post-processing fits into that picture like with the collector um a lot of your times revolved around like developers devops people who are working with the code like like how they're able to propagate data but what about that like not so much like tail based sampling where you're deciding right at the moment but like maybe a little further down the line being able to connect data points you know once you're holding five minutes of of Trace data yeah so one thing that's interesting there is that open Telemetry feels in many ways like an event based emitting style of instruments in your code but it's actually not that and the collector and other like um ways of post-processing data is where you start to feel that sort of impedance mismatch in particular um and so because of that um you can run into certain problems like the a great way a great example of that is that links can't be added after expanded there and so even uh as far as I know like once you create this fan you can't add a link to it even in push processing and so if you're trying to do that things are going to be really drinky maybe post-processing can fits that but I don't know that that's now I'm gonna go like research that that's wow okay cool yeah I mean I realize I have not done it I've been like digging through it haven't done it so wow okay so there is interesting historical contents there in that there used to be a method in the open Telemetry uh specification of you can add a link to his fan as long as this man is active then they took that method out several years ago and it's been an open um discussion and the um GitHub tracker for about three or four years now of this is absolutely useful we do end up needing this a lot and can we do that um apparently as far as I know the only way to do that is that's fan Creation in the options of the um for each band you can add links in there and that's the only time which means certain types of Instagram patterns or certain types of like that type of thing really really difficult to do and also means you know when you can approach process and then after that pretty much and then another way to think about the urban Telemetry commentary that's interesting is I actually view the counter and how to set up libraries and baggage and other things like that all as different types of convention-based out-of-band information and handling so when you build up conventions in your company or in your system or in anything like that you can start to say oh yeah if you set this information here then it'll be there or you can actually just assume that we'll have this information because the clutter will add it here so as an example um and when it's metal and a blog post in which they talked about they said of their collectors to actually add to every span what data center that's man came from what machine that span came from what um and then where everything was what cluster it was in and all this actually information so everyone can always clear all that information you don't know that like it's there because you read the documentation in the internal tooling and you can build internal tooling that works on top of that natural convention rather than something you can actually Express in your Telemetry itself anything else well I guess if there are no further questions thank you so much for for coming on for coming on twice and for putting this together I know uh presentations are definitely a lot more work to put together compared to just you know sitting there answering questions so definitely appreciate the time that you took to put this together um and to share your knowledge with folks I think there's uh you know so much are out there on on like the novice Hotel stuff but when it starts to get into the gnarly bits um we're definitely lacking in that information so we definitely appreciate um you sharing that and uh call out to anybody if you if you or you know anybody who is interested in sharing some Hotel goodies um in hotel in practice we would absolutely love to have you um and also if you want to share your hotel story we would love to have you for open a and I think we've got a session coming up later this month right Rhys we do we have a special discussion actually coming up on the 28th um it's going to be about the evolution of observability practices and actually Nika is going to be part of that panel um and we'll do a full announcement so um thank you Hazel for uh for everything and um I guess we'll see y'all um on the internet [Music] thank you [Music]

