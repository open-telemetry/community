# OTel Night Berlin – v2025.05 – Spring Starter for OpenTelemetry

Published on 2025-05-07T18:47:21Z

## Description

Gregor Zeitlinger, Senior Software Engineer at Grafana Labs, will guide you through the essentials of the Spring Starter for ...

URL: https://www.youtube.com/watch?v=R0n6Ny588dk

## Summary

In this YouTube video, the speaker discusses the Spring Boot starter for OpenTelemetry, focusing on its development, features, and practical applications. The speaker, who has extensive experience in Java development and OpenTelemetry, provides an overview of the current state of OpenTelemetry in Java and the motivations behind creating the Spring Boot starter. He compares it to existing solutions like Micrometer and highlights the challenges in achieving seamless observability integration. Throughout the video, he emphasizes the ease of use and native experience that the Spring Boot starter aims to provide. The talk includes a live demo showcasing the setup and functionality of the starter, with opportunities for audience questions interspersed. Key topics include instrumentation, API stability, and the importance of semantic conventions in observability.

## Transcript

# Spring Starter for OpenTelemetry

All right. I want to talk about the Spring Starter for OpenTelemetry. What I'll try to do is demonstrate how it works; it just works, but except when it doesn't—thanks to the demo gods, and because it’s Spring Boot.

## Introduction

About myself: 20 years ago, I started my first job as a Java developer in this building. I realized today that it wasn't the first location, but it was the first company, and we moved here from a different location in Berlin. I worked here for about three years. Ten years later, I started using Spring Boot. I still don't know everything about it. Five years ago, I started working with OpenTelemetry, and I definitely know that I will never know everything about it. Two years ago, I started working for Grafana, and now I'm an approver for OpenTelemetry Java instrumentation—the stuff that sends all the data, which you will see later. I also work on some other areas in OpenTelemetry, including the operator, collector, and specification.

## Overview of OpenTelemetry in 2025

I want to give you a quick overview of the state of OpenTelemetry in 2025, highlighting what’s new. Then, I’ll discuss the motivation behind building a Spring Boot starter in the first place. I also want to compare it quickly to another solution in Spring Boot called Micrometer. I plan to spend most of the time on the demo to actually show you that it is easy, leaving time for Q&A. But feel free to ask questions in between. I hope we have enough time; if we don’t, please ask before I try to finish the demo, as it may not work.

As you can see, we have quite a lot of languages in OpenTelemetry, and many of them have moved to stable for traces, logs, and metrics. I think that's quite a significant change from last year. Java, PHP, .NET, and C++ are included. For some reason, profiling is not listed here, but this is a new topic that is actively being developed, and I guess in a year or two this will also be listed.

## State of OpenTelemetry in Java

Java is one of the more mature areas in OpenTelemetry, probably because many e-commerce and business applications are written in Java. There's a lot of demand, and I counted over 100 supported libraries, which are also compatible with older versions of Java. Java 8 was released more than ten years ago, and this is only possible because Java has a technology called byte code manipulation. This means you can write software that, at runtime, looks at all the methods and classes that are loaded and can change anything. It can change a return value and look at parameters, similar to how Python can do monkey patching.

Now that I've explained how the Spring Starter works, the question is: Isn’t that good enough? Why did I and another engineer from Microsoft spend a huge amount of time last year working on making a Spring Boot starter? 

### Limitations

Let's start with what we cannot do or cannot yet do. We cannot match the huge number of libraries—more than 100—simply because we cannot change old code, and there's a lot of work being done. It would take a long time to have the same level of support for all libraries.

As a Spring Boot user, I prefer a native Spring Boot experience. This means I want to be able to select a library, add it as a dependency, and it should not require anything special. That is exactly what I wanted for observability; it should be built into the development process, much like adding a database. However, that’s not possible if you are adding a Java agent, which feels like magic.

As a Spring Boot user, you are also used to having a very integrated experience. This means you can take your configuration file, called `application.yaml`, and just add properties. The values and names of those properties are automatically suggested. For instance, you can easily select the service name, which we discussed a bit earlier.

You can also use another Java agent to do your other magic work, but adding two Java agents doesn't usually work well. Additionally, you can use a GraalVM native image that compiles your entire application into an executable, which starts faster but takes a long time to compile. I’m too impatient to show that to you, but there is a fully working example where you can try it out.

I spent a lot of time last year on this, and it became stable last year, so now I can talk about it.

## How OpenTelemetry Works

Before going into exactly how the Spring Starter works, here’s a recap of how OpenTelemetry itself works. This is not Java-specific or Spring-specific, but in the next slide, you will see how it relates to what I'm trying to show you. My personal preference for the order of importance is as follows:

1. **Protocol**: Once you have the protocol, and your application knows data is sent out, you can switch it somewhere else without recompiling the application.
2. **Semantic Conventions**: These define the names and attributes. For example, for a metric, it would define the metric name of the duration of a request and its units.
3. **API**: This is more for library authors who want to be compatible with OpenTelemetry and do not want to spend time rebuilding their observability stack in five years. The APIs are stable.
4. **SDK**: The SDK is an implementation of the API and provides configuration options like environment variables.
5. **Tooling**: The collector and operator are also very important and helpful.

## Comparison with Micrometer

Now, I want to compare the Spring Boot Starter that I've worked on to the existing technologies in Spring Boot to explain why we built something where a similar solution already exists. 

In Micrometer, you have two things: 
1. **Metrics**: This is quite old and used in many applications. Recently, a module has been added to export the metrics using OTLP.
2. **Tracing**: This is newer and was previously called Sleuth. While you can use the OpenTelemetry SDK to emit traces, it does not have semantic conventions.

Here’s the problem: it’s not using the same API, which has created confusion for users trying to combine libraries. They often don’t know if one is using Micrometer tracing and the other is using OpenTelemetry. Sometimes it works, sometimes it doesn’t.

I would love to have a common approach where either Micrometer APIs or OpenTelemetry APIs are used. However, this has not happened because the Spring folks have a rich tradition of maintaining their APIs, and OpenTelemetry wants to provide a consistent experience across all languages.

## Data Flow in OpenTelemetry

In OpenTelemetry, we have instrumentation libraries. In Spring, there are instrumentation libraries that are sometimes not maintained by OpenTelemetry but by the authors of the libraries themselves. Semantic conventions are essential for ensuring consistency.

## Demo Preparation

Now, I want to start the demo. If you have any questions, it probably makes sense to ask them now before we proceed. 

### Questions

Is it possible to work with Zipkin? Yes, we have a Zipkin receiver in the collector. You can send Zipkin spans to the collector, and they will show up as one trace at the backend. However, if the Spring application does not use Zipkin, it uses something else as a common denominator for both Zipkin and OpenTelemetry.

If you send both, they will show up, but they won’t have the correct parent-child relationship. This is because in Java, if something is asynchronous, you need an object to indicate the parent-child relationship. 

### Demo Execution

Let me try the demo before we run out of time. 

Here, I am in a project called `docker-otel-lgtm`, which has examples of instrumentation and a complete observability stack based on Grafana technology. I will explain what I have done so far and then we will add more later.

I have two Bill of Materials (BOMs). In Maven, this is the dependency management section. First, we have OpenTelemetry (the latest version) and Spring Boot dependencies. We want to ensure that the OpenTelemetry version is compatible with Spring Boot, and I’ve included a small controller that simply does dice rolls and has a player name.

Starting the application now... 

While it starts, I am also starting the observability stack in a Docker container. This is a task runner using a shell script that runs Docker. 

On the left side is the application sending data to the OpenTelemetry collector, which sends the data to various databases. 

The goal of this project is to provide an easy trial experience, optimized for startup time.

The application has started successfully. Now, I’ll generate some traffic using a curl script that pulls the endpoint. 

Let’s see if we have some data now... 

Yes, we have some dice rolls! Now let’s check the traces... 

Oh, we have an error. Let’s see what caused the error. 

### Observations

I can see that the error occurs because the observability stack was not fully started. 

How many of you have used Spring Boot? (Audience responds.) 

How many have instrumented OpenTelemetry in any language? (More hands go up.) 

How many have used the two together? (Only one hand goes up.) 

### Feedback and Improvements

If you see anything that could be improved, let me know. 

Do we need more spans? Yes, we could add more spans or even a database connection. 

If there’s nothing else, we can wrap up here, but if you have suggestions or requests, I’m happy to add more. 

### Conclusion

Thank you for your time!

## Raw YouTube Transcript

All right. Um, yeah, I want to talk about the spring starter for open telemetry. And, um, what I'll try to do is it just works, but except when it doesn't. So, that's, uh, for the demo gods and because it's spring boot. All right. Um, so about myself. Um actually what I didn't put on here but 20 years ago I started my first uh job as a Java developer in this building. Just realized today I Yeah. Yeah. Um it was not the first location but the first company and we moved here from a different location in Berlin to this one and I worked here for about three years. Um yeah 10 years later I um started using Spring Boot. Um I still don't know everything about it. Um five years ago I started uh working with hotel and I definitely know that I will never know everything about it. Um yeah and then I started working for Grafana two years ago and um now I'm an approver for hotel Java instrumentation. So the stuff that uh sends all the data but you will see that later. Um and I work a bit on some other areas in hotel um operator collector and specification. All right. Um so I want to uh give you like a quick overview of the state of hotel in 2025 what is new. Um then uh the motivation why building a spring boot startup in the first place. um also want to compare it quickly to other solutions in spring boot which is called micrometer. Um I want to uh spend most of the time in the demo to actually see um and show you that um it is easy and leave time for Q&A but uh you can also ask in between. I hope that we have enough time and if we don't then it's better if you ask before rather than I'm trying to finish the demo and it doesn't work. All right. Um so as you can see we have quite a lot of languages in hotel and um a lot of them have actually moved uh to stable stable stable for traces locks metrics. I think that's quite a bit of change for last year but I haven't recorded it. So Java which we are talking about PHP.NET and C++ and for some reason profiling is not listed here but this is like a new topic um that is uh an active development. I guess in a year or two this will also be listed here. Um and uh yeah I will not show that. Um okay state of hotel in Java. And Java is u one of the more mature areas in hotel probably because a lot of uh e-commerce and business applications are written in Java and there's a lot of demand and there are many many libraries um and uh just counted uh yesterday over 100 uh supported uh libraries are supported and it's also compatible with ancient versions of Java. So um Java 8 was released long more than 10 years ago but I did not count um and that is actually only possible because Java has a technology called byte code manipulation which means uh that uh you can write um a software that uh at runtime looks at all the methods and classes that are loaded and can basically change anything. It can change a return value and can look at parameters similar to how Python can do monkey patching. And uh now that I explained how the spring starter works, the question is uh isn't that good enough? Uh so the question is uh why uh did we or I and another engineer um from Microsoft why did we spend a huge amount of time last year working on making a spring boot startup. Um so let's start with what uh we cannot uh do or cannot yet do. uh we cannot match the huge number of libraries um more than 100 um simply because uh we cannot change old code and also because uh there's a lot of work being done um and u it would take a lot of time to have the same level and um then the question is what we can do and um as a spring boot user um I like to have a native ative spring boot experience. That means I can just select um a library add it as a dependency and it does is not anything special and that is exactly what I wanted to have for observability. It should not be anything special. Um it should be built into the development like you have a database. Well, it's probably kind of hard because without a database, you could not do anything. You could not serve customer requests. But it should be as close as possible to just adding a database. Um, and that is not possible. If you are adding a Java agent, then it's kind of this magic. Um, and as a spring boot user, you also are used to uh have a very integrated experience. That means you can take your configuration file called application YAML and you can just add properties and the the values and um names of those properties are automatically suggested. So you can basically um just select um service name because we we talked about service name a bit before and hopefully I can show you that this is very easy. Um, and then you can also uh use another Java agent uh to do your other magic work because adding two Java agents uh doesn't usually work well. And you can also use a Growlv VM native image which compiles your entire application into an executable which starts faster but it takes ages to compile. So I'm too impatient to show to that to you. But there is a full working example that uh where you can try that out. Yeah. Um and as I said I spent a lot of time last year and it also became stable last year. Um now I can talk about it. So um before going into exactly how the spring starter works um this is a recap of uh howl itself works. Um so this is not uh Java specific and not spring specific but in the next slide you will see how it relates to uh what I'm trying to show you. So um the order is uh my personal preference um and from most important to least important for for me the most important one is the protocol because once you have that protocol and you have your application you know data is sent out I can switch it somewhere else I don't have to recompile the application even if I don't have any developers and as we heard in the previous post even if the data is kind of crappy you can use AI I to make it better but you you need to have the data. Um yeah the next one is uh semantic conventions. Um because uh semantic conventions define the names and attributes. So for a metric it would be um the metric name of uh the duration of a request for example um and also the units. So metrics and traces for locks. This is a there is a bit of semantic conventions but not much. Third one is a API. API is more for uh library authors uh who want to uh be compatible with hotel and uh they don't want to uh spend time in five years uh rebuilding their observability stack and for that uh the APIs are stable and in hotel they are stable as you as you have seen in like here what it means stable is means the AP among others but one is that the AP API is stable. Um and one uh special thing is that for tracing the API is also important so that different uh libraries in the same process um know which uh parent span belongs to which child span because uh there are two cases. The easy cases you have a thread in Java and um the thread uh is for a request and the thing that is first in the thread is done first. This is a parent and the second one is the child. But sometimes you have um something that is asynchronous because it has an executive framework or something like that and then you need to have uh some kind of object that says this is a parent that is a child and that is what the API is for. Um lastly um SDK. The SDK is an implementation of the API and it also gives you configuration options for example with environment variables. The well the last one is not the least important one. It's just more like at the side the the tooling the collector and operator is actually very important and very helpful. All right. So now um I want uh to compare u the the the spring boot starter that I've worked on uh to the existing uh technologies in spring boot uh to to explain a little bit why we built something where kind of uh something similar is already there. So in micrometer um you have two things metrics is is quite old um and u used in many applications as far as I know um and more recently um a module has been added where you can um export the metrics using OTLP that's why OTLP the first one um but um as spring boot is older than hotel um they cannot just change the names um of their metrics or I mean they could but uh for spring uh they hold it very dear to uh not change anything for old applications because there are many old spring applications um um so changes are only in major versions and it takes a very long time and that's why they did not add yet add support for semantic conventions Um yeah but uh in in our in our spring starter so our when I say our it's not graphana where I work for but it's it's hotel as because um this is something that I worked on just as an hotel uh contributor um you can import those metrics because there are many applications and libraries that emit those metrics and in some cases can be useful to to use those micrometer tracing is The second part that is a bit newer. It was uh called something different uh slleuth. I think before it was called micrometer tracing but it's still newer than metrics. Um and in tracing you can use the hotel SDK um to emit um traces but it also does not have the semantic conventions even though it's newer. And um here you have the problem that it is not using the same API. Um that's why you have this problem here on the right side. Um and that has actually created um some uh questions and probably even more exploding heads that I'm not aware of for users who are trying to uh combine um some library with some other library. they usually don't know that one is using micrometer tracing and the other one is uh using hotel and uh sometimes works sometimes doesn't and sometimes works kind of um um yeah that's basically it um I would love to have like a a common um approach where uh there would be only either uh the micrometer APIs or the hotel APIs but this has not happened um because uh yeah this the spring uh folks have a rich tradition and they they know when they create an API they also want to keep it and u on the other hand the hotel folks can also or don't want to say oh we just take another API because it is for many languages and um picking a different API makes it very difficult for hotel users who are who actually love to have the same experience across all languages. All right. Um and this has been a lang a question that has uh been asked many times but so far uh nobody has really uh gave an answer to this. All right. Um this is basically what I said just more in a data flow kind of way. Um so in hotel we have instrumentation libraries um and in spring um there are instrumentation libraries in spring they are called native because they are not maintained by hotel and they are not repositories um but they are done by the the authors of different of the library itself. Um in spring this is sometimes also not uh they are also sometimes doing it for other libraries. [Music] Um and um yeah semantic conventions are I mentioned semantic conventions and later we will hopefully see why this is important. All right. Um that's actually it. Um, now I want to start the demo, but if you have any questions, um, it probably makes sense to ask them now before, uh, we go to the demo. All right. So, is used to work with um, zip key, right? Yes. And we have a zip key receiver in the collector. So, would it work to just send zip key to the collector and like does it work if I send zipin spans to the collector and hotel from my Python application to the collector and do they show up as one trace at the back end? I mean, I guess the question is on the context propagation side of things, right? Um, you could send both and they would both show up, but they would not have the correct parent child relationship because um internally Spring does not use Zipkin. uses something um else which is like a common denominator of both Zipkin and uh hotel because those are the the two targets for micrometer tracing. Um if if they would say okay we just want to optimize for hotel then it would work. Doesn't that work with the B3 headers? Um the headers are basically where it it's between processes. Yeah. Yeah, I mean I have a Python application that is sending data to my collector and hopefully that one generated a a span that originates the Java spans. Yeah, then it would work. So if if here between parent and child you have a process boundary, then it would work. If it's in the same process, then it only works in some cases. So if it's in the same Java thread, then I think it will work. Uh but if it's in a different Java thread because you have an exeutor then it will not work because the context is actually stored somewhere else as a matter object and Java does not have a context object like go for example does is that a property of Java or spring like kind of is that could this also happen just with general Java applications because I'm just thinking like we sometimes see that there are incorrect parent child relationships in spam and we're mostly using Java but I'm not sure if they only use spring. So I'm just asking like there are there are many uh scenarios where this can happen. Um even if you just use the Java agent which is like one distribution um it usually uh is because there is some other context propagation mechanism that is not uh supported or a library version uh upgrade uh changes the version how context is propagated. that that sometimes happens. But if it's between threads but in the same process, then it couldn't be you said like if it's in the same process, it could still like lead to this mismatch. Yes. But if it's in the same process cannot be like different methods of propagation at least I understand propagation is in between process. Oh, there propagation is the term that is both used between processes and also within the same process. Between processes you have um headers uh like Jerasi said B3 headers for example that are added to HTTP and in the same process it is uh some language specific u passing. Um so in Java by default the context is stored in a thread local because uh you can store a thread local without modifying the application. You don't have to pass a parameter. Um but that only works so long as uh the entire call is in one thread and uh new applications typically don't do that because this is not very efficient. So in general there is you have to expect that there are like linkage breaking between parents and child with Java. Um no no no no um the the Java agent authors uh have support for those technologies or libraries where it's not easy. So uh Java um exeutor for example is a framework where you can pass a runnable to a different in a pool and then it will be picked up by a number of different uh threads. um and they they do round robbins so that you don't need a thread for every request and um this bite code manipulation thing of the Java agent can see when uh you put an object into this uh pool and then it will um attach some metadata into that object. So uh maybe there's a map where you can put things into and then you can add a context ID I know a thread I u trace ID and a parent um span ID and then you can uh form the correct parent child relationship. But if that uh support is missing in the Java agent and here in the spring boot starter it it would be the same. If the spring boot starter does not support this then it would not work. What is even more difficult is if um there are two different instrumentation technologies that don't use the same API then they also don't know what they should expect as a context object and that is what is making it so difficult to combine a micrometer and hotel instrumentation. This might be the beard talking, but I miss EJB context. EJB. I mean, EJB context was perfect for this kind of situation. Does EJB even still exist? I don't. Maybe it would have been the solution. How old I am. The last time I used EJB was when I was in university. And as I just said, it's more than 20 years ago. Yeah. All right. Um, let me try with uh the demo before we run out of time. How much time do we have we left? Um, it's you have Okay, good. Good. As long as you still have some energy left. So, um, yeah, this is my, uh, Intelligj. Weirdly, it does not look uh, black even though like here I have the black theme. Oh, no. Oh, okay. Let's see if it does. Yep. Oh, it's Oh, wow. Should have checked that table. You just turned it off and turn it on. Yeah, it's all you have to know as an S. Okay. Um so here I'm not just in any project but I'm in the project uh called docker hotel lgtm which both has examples of uh instrumenting and also has a complete observability stack based on graphana technology of course because I'm working there um and uh I have created a new example um just so that it to get us started a bit faster. um and going to explain you what I have already done as the first iteration and then we we'll add stuff later on. So here I have uh two bill of materials. So in um we are using Maven this is a dependency management section and first we have open telemetry this is the latest version and then we have spring boot dependencies we have uh the open telemetry first so that uh if they are um libraries with the same name the one from the first one win and since uh spring boot has a micrometer um which has the hotel exporter but in an older version I want to make sure that we have the newer version and that they are compatible and then I just have a um starter web which is from spring and then I have the open telemetry spring boot starter and then there's really nothing here I don't know why we have repackage we have a spring boot app but there's nothing interesting here and then we have a small controller that uh is just doing uh rolls and it has a player name. So, first I want to start this. And while this is starting, I'm going to switch here where I have two windows. The first one is actually uh starting the image where we have the complete observability stack. So this one is actually just a um docker um script but um just to show you what this is really doing. So mis is just a task runner. So like make file but a bit nicer. And this one is just a shell script. And the shell script is just Docker. The only thing why I don't call Docker is that I probably forget some of the ports. By the way, I did not mention the ports. Yeah, I did not mention the whole slide because it said demo. Um, this is explaining the project uh much better um than I could do. Um so on the left side is the application that we're doing that is sending all the data to the hotel collector um which is sending the data to all the databases. The profiling one is uh not used here and then we can view it with graphana and that's why we have two ports on the left and one port on the right side. Yeah. So this is just um passing um the ports and uh some people like to actually persist the data but the the goal of the project is more to have an easy try out experience. So it's not optimized for uh uh scalability but it's optimized for startup time. Did it work out? Yeah, it started in 3 seconds. That was uh the latest uh iteration that I did because uh it was taking half a minute before. And then it also has an environment file which uh it's not really needed but I set it here to um an external endpoint. So I can also view the data in graphana cloud but this is actually not needed. Um okay so back to our application as it started now. Yeah I think in the beginning it um sent some errors because the observability stack was not started and now I will also put some traffic. This is just a curl script that pulls the endpoint. Sometimes it gives an error because the error is simulated. See if we actually get some data now. Yeah, we have dice rolls. Now let's actually see if we can see some data. Yeah, we have some data. We have some traces. Are the traces? Oh, cannot scroll down. Okay, so nothing really interesting. Uh why is it not interesting? Well, because the service is not calling any other service and it is not calling a database just sometimes has errors. Do we see errors? Let's see if that at least works. So this is by the way the graphana 12 that was just released today. I hope I'm uh using that correctly. Error. Yeah, it's error. So, [Music] here we have an error. Let me see if that works. Copy that. And Does it work? Oh, I did not copy the entire thing here. There's copy. Yep, that's where the error is thrown. Okay, so that part works. Oh, what I forgot to ask. Uh, how many of you have used uh Spring Boot? Okay, at least a couple people. Um, how many have instrumented Open Telemetry in any language? Even more. Good. How many have used the two together? Oh, one. Okay, good. Okay. But uh next question is not about instrumenting. Do you see anything that that could be improved that we should make better or that you want to have added more more spans? More spans. Yeah. Um an unknown service. Exactly. Unknown service. And I promise that this should be easy to do. So let's see if we can do that. Um, where's my directory here? Very slow today. So, let me see. Sir, this [Music] Service service hotel service name. No, but it's a different one. Okay. Um, let me see if I have hotel. Oh, is it not recognizing? Maybe I not I have to reload. Maven did work. today. But the goat the goat. Yeah, I did not sacrifice a goat. So I guess I have a question. Why do you look look it up? Um the new way of doing things is using um hotel config files that can be reused across services. That is right. Yeah. would that come to to the um the screen boot starter as well like can I could I just add my hotel.l file there instead of um configuring to the partition. Yeah. So before answering it just a bit on the background um right now um in hotel the standard way of doing things is environment variables and that is uh quite limited. Uh so the like the most fancy thing is if I write uh hotel resource at oh it's even completing that but this is not spring this is u the AI so I can say service name service version something like that um and anything more complicated uh is uh specific to any language um and is currently blocked and uh what I'm unsuccessfully trying to show you is the only way where where you can currently use YAML as far as I know. Um and what Drussi is saying is that um the the plan currently is to have the same experience well not in spring syntax but in YAML or in any unstructured any um structured data um to have the same experience. Um, and for spring we would probably have a major version where we would tell you to switch from the syntax uh that I'm trying to show here to the one that is compatible. I have spent some time trying to figure out if this can be integrated with spring because here you can also use a spring expression. So in spring you have a a u language where you can reference environment variables. I don't know if I can if I get it right if that is actually correct or if this is just an AI hallucination but it's there is a spring feature where you can reference other parts in spring and you can even reference Java beans and so on. And what I want for the future is that you can also have this because you're used to it as a spring user but with the common YAML format. I'm not sure if that is possible because um this is already stretching the limits of spring um and um it will be even more so with the new format. So I hope it's possible but uh no no promises. So, okay, since I'm trying to do that here, I'll just uh look in my stash to see if uh I'm just too stupid to find um the right format. Resource attributes, hotel service name. Yeah, the autocomp completion just didn't work for some reason. It's not suggesting it. So show up as a plugin on the right hand side. There's no plugin, right? Actually this is a feature of uh the um dependency here. So it basically just has a JSON file where it lists all the properties and it yeah should work. Let's see if it's uh if it's working. If we restart the service um so here tracing is always uh the tracing locks is the fastest to show because it's processed right away. metrics is ingested every minute. Um you can change it to more often but um for this demo it's not necessary. So see the last one. No, it still has unknown service. Well, what I had before is that when I started in spring, it's not working. But when I use maven to start it then it is working. So that can can be tricky. Let me see if that is the case. Oh, it's still unknown service. They look for unknown service. I think that's too old by now. That's still a node price that you were looking at. Can you filter by service? It's it should it actually says service name here. So, it's automatically grouping by service name. That is not the problem. I'm probably doing something wrong because I put it in a wrong directory or something. something that is uh a typical spring problem that uh that happens uh every time when I try to do something new. Okay. Um I'm just going to delete that file and apply the stash as I had it before. Oh yeah, it's in a different directory. That's That's why my error. Yeah. Okay. Good that I had the stash. Let me see if I can also type service. Yep. Now it works. Okay. At least that worked. Okay. But now I made the mistake that I started it here and also in the other one. It's probably saying that the port is already used. Started it here and no seems that it is loaded. Okay. See if it works better here. Here. Here it is. Okay. Here's rolled dice. Okay. Then let's just look at that instead. So here now I can show you where the service name is. Here is service name and then you also have a bunch of stuff that we did not specify and that is because there are resource detectors uh so that you don't have to do all the work yourself. So for example, you have the process ID that that was taken from the operating system and and you can also see that it was created by the spring boot starter. So if you're reporting a buck, then it's easier for the authors to find where this is coming from. And you have also this uh correlation that you have between some metric types. You can actually see the trace that was the trace that that's that uh started before the lock message was emitted. Okay. Um now that we have that al let's look at some metrics. Uh so there are um there is this duration metric that I talked about before. Um and that has the same name across all languages. And that is really useful for having an APM system where you can uh see what uh what the request rates um for all of your services are. Um here this is the open source version of Graphana. So you don't have the APM tool here. All right. Um I would have uh some things that we could do. We could add a manual metric or um a so an additional um metric where you can count the number of requests or players. Um we can add more um spans. I heard that before. Or we can add a database or we do nothing of it and we just leave more time for questions. [Music] So if you don't have anything that you want then I think we can just cut it here. But if you want something then I will add it. Yeah. I just have quick question. Why service main not on the resource attribute? Oh yeah that's a good one. Um let's I think we saw it here. Um that is uh the visualization of uh Loki. Loki shows everything flat and it's actually you're not the first one to notice that it it would be more useful if that was structured in traces. It is structured. Yeah. Yeah. It's a good point. I think it would be better. And now it's also showing up here for some reason didn't before. So here it is in resource attributes and it's down there. It's there. Service name, right? Yeah, here it is. But in the configuration you have to add it to a different place or is that like kind of free? You can Oh, service name is special. Uh in open telemetry service name is special. Um it internally it translates into resource attribute but it is like the single one that is required by every every telemetry data that I could also add it here by the way. Yeah I also find that confusing that there are two ways and I just had a customer call today where we found out that in some cases it does matter where you put it even though it should not. Yeah. Yeah, I mean I think yeah it's an implementation detail. Um basically service name is the only required attribute for open telemetry and it it is top level. An implementation detail is it is a resource attribute and so that's why sometimes it works sometimes it doesn't. I mean in theory it should only work if it is at top level right because if you add it as resource attribute then it's probably not recognized at the top level. Um confusion in OTLP it it is only resource attributes so it's only within the resource attributes that is a special one called service name and that's it uh so that's why some if you specify environment variable with the service name it it might work but then depending on the library um if you don't have the proper service name environment variable it overrides the the one that you would override with the resource attributes with a default one so that's why sometimes it doesn't work sometimes it So if as a user you should only use at the top level not at the resource attributes. So when I see in graphana on the resource attributes that's just the dual thing basically. Yeah. Is that really true? It is how it is internally uh stored. Um so in graphana you see in two places. One is uh if you go back there to to the screen uh you see the the at this um here. Yeah, if you go up there you see the road dice uh up there at the very like the trace summary. Um even more here service even more so perhaps even more. So no I cannot go up more. You can go here. So here is a service name. So that's okay. Yeah. Yeah. Got it. So but uh internally guess the service name that is within resources. So in graphana I know if you go like to the traql um quer so instead of using traceql itself it has this kind of building query by the same then there's like the top two or so. Yeah exactly. So if you go to search now not the trace. So service name, span name and status are like the special one. Yes. Well um for open telemetry only the service name is special. Um the folks at tempo they said you know span name is interesting to have it as part of the trace syntax and so it's there. Um but from the hotel perspective the only thing that we require is a service name. Even even then we don't throw an error. uh the specification says that if a service name is not specified the unknown service should be used which is what we've seen before right so the spring boot application was working without the service name and it was showing unknown service but it is a it is against this spec it should resources then in the application yo you should not put it under resources no no it's it's perfectly fine it works yeah but as a user you should not as a user you should pro probably not do that Yeah, got it. Okay. I mean it might work for spring but it might not work for only lambdas. I mean I think perp spec it should work but the case I had today was where it actually did not work. They were putting it in environment variable but it's basically the same. Most people I think most authors expected in service name that's why it's safer to put it in there. Yeah. This is also just my last obligatory slide. That's why I put it on here. Cool. All right. Thanks for your time.

