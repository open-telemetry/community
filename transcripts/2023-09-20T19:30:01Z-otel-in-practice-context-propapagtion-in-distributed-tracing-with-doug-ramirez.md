# OTEL in Practice: Context Propapagtion in Distributed Tracing with Doug Ramirez

Published on 2023-09-20T19:30:01Z

## Description

Join Doug Ramirez of Uplight as he talks about Context Propagation in Distributed Tracing, using Python examples. #OTel ...

URL: https://www.youtube.com/watch?v=Of_ygNU_Cbw

## Summary

In this YouTube video, Doug Ramirez, a principal architect at Uplight, presents a session on distributed tracing and context propagation within microservices, part of the OpenTelemetry initiative. He provides a straightforward explanation of distributed tracing, which helps in understanding how various services interact in a microservices architecture. Doug discusses key concepts like spans (units of work) and traces (collections of spans), emphasizing the importance of context propagation for observability across service boundaries. He demonstrates a minimal code example using a fictitious "band database" API and a review service, highlighting how to implement distributed tracing using OpenTelemetry SDKs and W3C recommendations. Doug addresses practical considerations, including privacy concerns and the benefits of integrating logging with tracing. The session concludes with an interactive Q&A where Doug encourages further exploration of the tools available for developers.

# Hotel in Practice - Distributed Tracing with Doug Ramirez

[Music]

Thank you! Hi everyone, thanks for joining us for Hotel in Practice and for being patient and sticking around. We've got Doug Ramirez from Uplight joining us for a second time, this time in the Hotel in Practice capacity. He has joined us previously for the Hotel Q&A session, and in case you missed that, we do have a blog post summarizing that session on the Hotel blog at OpenTelemetry.io under the blog section. 

So, I guess without further ado, here's Doug!

---

**Doug Ramirez:** Hi everyone, I am Doug Ramirez, a principal architect at Uplight. We do cool things to try to save the planet. Just a shameless plug: Uplight.com/careers, we're hiring, and we're a B Corp! But let's move on to OpenTelemetry and distributed tracing.

Today, I have a few things I want to cover:

1. Introduce the concept of distributed tracing and context propagation.
2. Share a very minimal example of distributed tracing in action, peeling away a lot of the extraneous stuff and noise to show you how this is implemented in just a few lines of code.
3. Share some resources for further exploration of distributed tracing.

So, what is distributed tracing? It’s an observability concept that gives us a big picture of how our myriad of services interact. If you think about the three main pillars of observability—logs, metrics, and tracing—they have all been around for a while. Distributed tracing, however, has become increasingly important as microservices architecture gains popularity. 

**Key Concepts:**

- **Spans and Traces:** A span is essentially a unit of operation or work. For example, a database query is a great example of a span. A trace is a collection of these spans and tells the story of how a request traverses various services. Each trace has a unique identifier, which is globally unique and random. 

- **Trace Context:** This is like the envelope or baggage passed between services to uniquely identify the request. There must be an agreement on the format and specification for the trace context. The W3C provides recommendations on how a trace context should look, which the OpenTelemetry community has codified into SDKs and tools like the OpenTelemetry collector.

The W3C recommends using HTTP headers to send information from one service to another. The two headers specified are:

- **Trace Parent:** Packages unique identifiers describing a unit of work in one service and the associated trace to send to another service.
- **Trace State:** A simple list of key-value pairs that can carry additional information.

**Privacy Considerations:** It’s important to familiarize yourself with privacy considerations surrounding personally identifiable information (PII) and GDPR compliance. Following the W3C recommendations and using OpenTelemetry specifications is generally safe, but it's worth noting.

To summarize, distributed tracing helps us observe how a transaction or request traverses multiple microservices. Fortunately, there’s a widely adopted specification and tools available from OpenTelemetry to make this implementation straightforward.

Let me pause here because I know that was a lot of information. Does anyone have questions about these concepts before I dive into some code?

---

Now, we're going to do some live coding! I've created a minimal example of a couple of microservices working together to demonstrate how to use the W3C recommendation and OpenTelemetry libraries. 

In this scenario, we are building the Internet Band Database, which will allow us to create a source of truth for band names and reviews. We have an exposed endpoint that allows a caller to request a band by unique ID along with its reviews.

**Live Coding Example:**

1. **Initial Setup:**
   - I want to add tracing to our service to see what’s happening. I’ll bring in the OpenTelemetry SDK and use it to handle the trace context.

2. **Adding Tracing to the Band Service:**
   - I’ll allow the caller to send the trace context in the header. When I start a span for the get reviews function, I’ll inject the trace context from the caller.

3. **Client Interaction:**
   - When the client calls the API, they’ll send the trace parent header. We will observe the time it takes to get a response and see where any bottlenecks occur.

4. **Using Jaeger for Visualization:**
   - Jaeger is an open-source platform that helps visualize traces and spans. As we implement tracing, we can see which parts of our service are slow and where improvements can be made.

5. **Debugging:**
   - If we notice that the get reviews function is taking a long time, we can dig into that specific code and see what the issue might be.

6. **Iterating and Improving:**
   - We can continuously improve the service by observing the performance metrics we gather through tracing.

Throughout this process, we will leverage the OpenTelemetry SDK to handle the heavy lifting and ensure our services are traceable. 

---

**Q&A Session:**

After demonstrating the implementation, Doug encourages questions about context propagation and the overall implementation. 

**Audience Questions:**
- How did you find the documentation around context propagation?
- What’s your experience integrating logging and metrics with OpenTelemetry?

Doug explains that he started with logging, as it is familiar to most developers, and recommended using OpenTelemetry libraries to include logging signals in their applications. He believes that this approach makes it easier to integrate tracing later on.

Doug also expresses interest in collaborating with others on this reference implementation and suggests that it would be beneficial to have detailed comments in the code to clarify what each part does.

---

**Conclusion:**

Thank you everyone for joining us today. We appreciate your engagement and Doug's insights on distributed tracing. Keep an eye out for our next Hotel in Practice session. 

If you're interested in further discussions, please reach out via the provided contact information.

[Music]

## Raw YouTube Transcript

[Music] thank you hi everyone thanks for joining us for hotel in practice and for being patient and sticking around um we've got Doug Ramirez from uplight joining us for a second time um this time in the hotel and practice capacity he has joined us previously for the hotel q a session and in case you missed that we do have a blog post summarizing that session in the hotel blogs in open Telemetry i o under the blog section so I guess without further Ado um here's Doug thank you hi everyone I am Doug Ramirez I'm a principal architect at uplight um we do cool things to try to save the planet um if uh just a Shameless plug uplight.com careers we're hiring we're a b Corp we do cool things uh but let's move on to open Telemetry and distributed tracing so I have a few things that I want to try to do today and uh that those are to introduce this concept of distributed tracing context propagation I want to share a very very minimal example of distributed tracing and action trying to peel away a lot of the uh extraneous stuff and noise around this so that you can just see in as few lines of code how this is implemented and then also share some resources around uh just more resources for people to go and explore distributed tracing so um so what does distributed tracing it's an observability concept that gives us a big picture of how our Myriad of services interact with each other if you think about the three main pillars of observability logs metrics tracing you know those have all been around for a while distributed tracing has been around for a while but as as more and more of um microservices architecture becomes a thing and becomes popular it really makes um it really kind of elevates the need for the ability to trace things that span uh process and service boundaries um there's a lot of things that monoliths give us and uh you know with with microservices it's it's really um like I really think that if you're going to move towards microservices you really need to make sure that you're you're treating distributed tracing as a first-class citizen as part of that implementation um and context propagation is the mechanism that gives us the ability to to observe things that happen in a service as a transactional request spans another service and another service and kind of your call chain of microservices context propagation is the thing that gives us the ability to watch and see what's happening um so a couple of Concepts that are important to know about when it when you're thinking about distributed tracing and context propagation or spans and traces um and in my experience oftentimes I think people flip the tune um but to be clear a span is is um it's basically a unit of operation um a unit of work you can think a database query is a great example of a span that's a unit of work that a service you know does there's a collection of these units of work that make up you know the the the the the transaction that may happen in the service and so a span is a span is nothing more than that unit of work and a span ID is the thing that uniquely identifies that you know unit of work a trace is just a collection of those spans and it tells the story of how a request you know traverses all of these different services that um that essentially enable a use case or a feature or a capability um and each Trace has a unique identifier um which is globally unique and random and I put some links in the readme here so that you can read more about um the uh the reasoning behind that but I think it's important for people to know and I know this has come up in conversations that I've had with people around what a trace ID is and it is important that it is globally unique and random for reasons that are explained better in the documentation from the w3c which I'll get into a moment until in a minute here um and a trace context is essentially kind of like the envelope or baggage that it's passed between services so that they can understand you know what uniquely identifies the request that's coming into them have a uniquely identify a transaction request that's going out of that service to another service and essentially um in order for all of this to work there has to be an agreement on what that format and what that specification is for a trace context and one of the things that we get as developers which is awesome is a recommendation from the w3c around what a trace contact should look like and we also get the benefit of a lot of the work that the open Telemetry Community has has done to codify uh those those recommendations and specifications into sdks and into other things like the open Telemetry collector that give us as developers a really easy way to implement distributed tracing context propagation there's an agreed upon format that is you know recommended by the w3c on how to do this there's a software in libraries and specifications that the open Telemetry Community gives us to make all of this really really easy and I'll show that in a moment um so with that specification that the w3c gives us um part of that recommendation is to use HTTP headers to allow a service to send information to another service so that that uh that Trace context can be propagated and there are two headers that the w3c recommends for doing this it's a trace parent and Trace State Trace parent is where we package up the unique identifiers that describe a unit of work that's happening in one service the trace that's associated with it to send to another service so that they essentially can unpack that tag that unit of work in the other service with information so that as that information is admitted to an observability platform that we can tie all these things together and we can see how this call chain of things that happen that span Services all work together and you know back in the day with monoliths it was pretty easy to observe and debug things that span different sub components of your monolithic architecture and we kind of lose that ability with microservices but we get it back by leveraging this Trace context concept and the um the the headers that are specified from that the w3c recommendation to pass that information between services so okay service a service calls another service it simply uses a header to package up some information it's an agreed upon format for other services to unpack and use to tag the spans and units of work that those other services are using um there's some details in here about like what the format of that is uh let me reduce my font here so you can see what a an example of a trace parent would look like so there's a version I'm not going to get into the version today nor will I get into the trace lags but the really important part of this is to understand that this ID here this unique identifier for the trace ID is the thing that will allow us to tie all of this work together so that we can observe how microservices are all working together to you know enable some feature satisfy some use case in addition to the the trace parent header the w3c recommendation also offers another additional header called tray state which is really nothing more than a simple list of key value pairs that you can add along with your the context that's being propagated between services so that you can attribute that to things that may be unique to whatever it is you're doing um vendors May uh use Trace State to provide observability into what they're doing but um you can just think of it almost just like a little bit of baggage that rides along with the trace context that moves between the services um so I have some links in here to the the w3c trace context specification and recommendation one of the things that I think is is worth calling out and I would encourage anybody who's going to go down this path is to make sure that you're familiarize yourself with the privacy considerations you know in this day and age with with pii and and gdpr and a lot of the other things that we really need to pay attention to as it relates to the the um potential leakage of personal information there are some considerations that are worth noting I will say that in general that following the w3c recommendation using the specifications in the libraries that we get from an open tem Elementary this is a very safe thing to do but just to kind of like be clear spend some time and just make sure you get yourself familiar with those privacy considerations so so I know that I ran through that quickly because I know we're kind of pressed for time but essentially you know this thing called distributed tracing again it's a way to you know observe how a transaction or a request traverses multiple microservices um again the good news here is that we have a specification that's widely adopted and it's widely known we have tools that we can use from the open Telemetry to employ this so for anyone who's thinking about like I'm building a bunch of microservices I need to observe how they're operating how do I do it the good news is is that that problem's been solved for you there's a de facto standard there's tools that you can use and uh as you'll see in a moment it's it's actually quite easy to do um let me pause there because I know that that was probably a fire hose of stuff but I want to see if anybody who's uh on the call right now has any questions about these Concepts before I jump into some code okay um we're gonna run with scissors now and we're gonna do some live coding so what I've done here is I have um again what I tried to do was to just create the most minimal example of a couple of microservices all working together um to demonstrate uh how you can use the w3c recommendation and use the open Telemetry libraries to do this stuff so in this scenario um we're building the um it's kind of like IMDb it's the instead of the Internet Movie Database it's the internet band database and so I want to I want to create like this source of Truth when it comes to bands names and uh and also um in this scenario we have we're leveraging a platform that just handles and reviews just a generic platform for reviews and so we're we've created it we're creating a band's API that our front-end developers are going to use to build web and mobile applications on top of and and and rather than building a reviews platform ourselves we're just going to leverage this fictitious reviews platform so in this case um we've exposed an endpoint that allows something to call and say hey give me this give me this band that has a unique ID and give me the reviews associated with it so I'm going to call the endpoint to get a band in its reviews and wow it took six seconds that's a long time let me run it again just to see what's happening here 12 seconds is a long time um so you can imagine we're all familiar with this right like you're building the service you've got people that are riding front ends to it and they're saying hey Doug uh I'm calling the endpoint for to get a band and it's taking a long time and that's not a lot of information to go on and debug you know I think we're all familiar with those scenarios where um you know somebody contacts you and says hey you know we've been noticing that this doesn't seem to be performing very well um we have to do that guessing game of like okay well when did you call this service like do I start grabbing a bunch of logs it becomes very tedious so one of the things that we that helps is to you know employ some tracing and some distributed tracing so what I'm going to do now is say all right hey uh from a developer um I'm going to add some stuff to my service and all I need you to do is to make sure you pass me some information when you call me so I know that you're calling me and then we can kind of debug this and see what's happening so the first thing I want to do is I want to go into my my my bands API and this is just a very very simple fast API application just a very simple model for a band I have an endpoint here that lets uh a caller get a ban by its ID I have a little helper function here that does some work to go actually access a data repository of reviews which happens to be this other review service that I mentioned before uh so let me bring up my my cheat sheet here so let's start by um bringing in some code that will provide some visibility with tracing so what I'm doing here is a couple things one is I'm going to bring in some um with the help of the open Telemetry SDK I'm going to bring in the library that's going to help me essentially tease out information from the header that I talked about a moment ago this Trace parent header and inject it into um essentially a hook that will call out to another service and omit that tracing signal and in this case I'm going to use Jaeger um uh all populated about open the open Telemetry collector but in this case I'm just going to bring in some code with the SDK give the band service the band's API the ability to unpack that header and inject that information to admit a trace so that we can see what's happening oh yeah so the get reviews so let's go to our get reviews so excuse me this is the function that does the call to the reviews service so what I want to do here is say okay for my when I call the get review service I want to start some kind of Trace so I can see what's happening and in this case I'm starting a span in my service and what I want to do is I want to actually I don't want to do this just yet sorry let's just do this and then back over here I'll explain what I'm doing here so what I'm doing now is um I'm adding a couple things I am um I'm creating the ability or what I'm doing is I'm bringing in a very very small Library of uh this is just a helper library that is essentially uh provisioning the uh the Tracer that we get as part of the open Telemetry SDK what this Tracer will do is this is the thing that will um build up the trays and send it to an observability platform in this case it's going to be Jaeger and uh in case you're wondering there's some default stuff that happens like the um the open Telemetry SDK knows to send to a certain Port that a service is listening to in this case it's four three one seven um and Jaeger's running locally so it will pick it up that's a lot of hand waving uh but in the interest of time just just know that the SDK is handling a lot of this stuff for you back in my band service what I want to do is say Okay anytime somebody calls the service um what I want to do is I want to allow the caller to send that Trace contacts in the header and so in my service what I want to do is I want to tease out that Trace parent header because I know that there's a standard and a specification for that I'm going to build up a carrier and I'm going to inject that or I'm going to extract that carrier from the payload and then I'm going to inject that Trace contacts from my caller into my contacts so that when I build up a span the open Telemetry SDK is going to do a bunch of magic and work for me and essentially emit that Trace to the observability platform so I have this now built up in my code so the bands API now can receive a request build up a Trace Loop in that Trace context from the caller and and when it calls its own internal function we're going to spin up another span which is a unit of work to make a query to the reviews platform so this will start to give us some of visibility into what the caller is doing and what the band service is doing so now let's go so what I want to say to the caller then the person who's building this application to say hey I'm adding some stuff to our service because I know you said it was slow and things don't seem right send this bit of information so that we can start to really observe what's happening here and kind of dig into what the problem may or may not be so if I go back to my client what I want to do is I want to essentially say hey help me help you by sending this header and when you send this header manufacturer a trace and a span on your end add that header to the call that you make to me and then we can kind of start to dig in to see what's happening here so now at this point we're kind of wired up now to like get a bit more observability into what these different services are doing so if I run my if the client now calls me I can see it took five seconds oh I forgot one thing sorry so I also just kind of want to print out to the console a little a nice little helper thing just to link me right to Jaeger where these traces are being sent to so I can start to see what's happening so now the client calls me again we should be able to start kind of digging into what's going on here wow 15 seconds is a long time so now I can kind of dig into this and I can see and I I don't I'm not going to spend too much time on Jaeger but Jaeger is an open source platform that's um that essentially helps visualize traces and spans so now that I have the caller following that w3c recommendation passing that Trace parent with some you know unique identifiers of the unit of work units of work it's doing sending it to the band service the band service is taking that information its context has been propagated to it it's leveraging that to emit information about what it's doing and now we can observe what's happening I can see that the uh the bands the get bands endpoint was called and I can see that the get reviews function unit of work was run and if I look at this um the spans table here I can see that the majority of time that was spent here was getting the reviews so that's a nice that's that's good helpful information to know right I can see like okay get reviews is taking a long time let's dig into that so let's go back to our code and I can say hey guys building folks building the client I see something going on in my service let me dig into it the get reviews is taking a long time hey what's this debugging thing uh somebody did something while they were debugging I just have a random timer here let me just get rid of this sorry about that folks right okay hey I just deployed a new version of my service call me again still taking a long time something doesn't seem right so now in this fictitious world I'm going to turn over and turn around to the folks that work on the reviews platform and say hey you know we're looking into an issue there was some random code that was sleeping in our end uh can you take a look and see what's going on in your platform because when we're calling you like it's taking a really long time to get reviews like our service seems to be working pretty fast so now let's go and do the same thing on the reviews end um very similar bit of refactoring let's go to the reviews especially let me bring yeah let's bring all this in so now the same uh the same service here gonna bring in this helper function to um start up the Tracer again leveraging the open Telemetry SDK to do that we'll bring in this Trace context propagator so that we can have this service do things they're interesting things with the trace context and let's see so here we want to do something that's a little bit different than the band service does right yeah I think that's right so now the review service can also receive that Trace parent that Trace context unpack it and Associate it with its span of work in addition to that we want to start a span and the uh at the internal um imagine this would be a piece of code that would more than likely read from a data repository a data store that's associated with the review service so now I can say okay folks that are building the front end of mobile app we've we've released a new bands API we've released a new reviews API that we we think we're going to help you know give us some visibility into what's going on so they're going to keep going doing their development they're going to start making calls to us four seconds isn't too bad let's try again it's still taking too long so now we got to figure out okay well what's going on so let's go back to our observability platform Jaeger and what is happening uh not skiing I'm not seeing the trace from the reviews out of this uh this is what you get when you try and run with scissors and do live coding um what am I missing here Chase parents so this is getting oh I know what we did all right folks there it is Okay the reason that the review service wasn't getting the context propagated because I didn't add that in the so in the band service is calling the review service we need to propagate that context um be quiet Siri here we go all right I know I'm jumping around quite a bit um so in the band service it's getting that Trace context from the caller it's attaching it to a span it's making this call to get reviews get reviews we want to see what's happening in that unit of work so we're starting up a new span but we also want to take the contacts from the caller and inject it into a header so that when the band service calls the review service that context gets propagated to it as well so now when the caller calls the van service it's spinning up this Trace ID this unique identifier sending it to the band service the band Service is like thank you very much I can attach this to my span this my units of work I'm going to send it Downstream to the thing that I rely on it's going to attach this information to its units of work and we should see all of that come together in Jaeger boom all right service is still running slow but at least now we have some visibility into what's happening oops and if I go to my uh Trace graph sorry my stands table actually where is it I can see here that the majority of the time seems to be sent be being sent being spent sorry and getting the reviews from the reviews database so when it's getting a review by getting the reviews for a band by the band ID it's taking a long time so let's go back and start digging into that code there to see what might be happening so in the review service if I look at this function that you know is grabbing data from some kind of data Repository again somebody put in some kind of sleep maybe they were debugging testing some timeouts who knows what but let's pull that out and now we can say hey folks that are building the mobile and web app we think we fixed it from real this time can you try again wow that's better let's go back and see what happened in Jaeger okay things are taking milliseconds that feels better I like this now I can observe what's happening across all of these different things yay team um so uh just to kind of walk through the code one last time the client is packaging up this header based on the w3c recommendation it's passing that header along to our bands API our bands API is leveraging the open Telemetry SDK and saying hey let me pull this stuff out and inject it into a carrier so that I can send it Downstream and by the way when I'm creating my spans um you know I'm gonna leverage that information when the review service gets a call into it it can tease out that Trace parent information and inject it into its fans by attaching that context and now we have distributed tracing with context propagation because we've got this awesome stuff from the open Telemetry community and we've got this awesome recommendation from the w3c let me stop there and ask if anybody has any questions about the the uh the kind of the basic minimal implementation of these Concepts in these handful of fast API services and maybe this is a good time just to kind of open up to general questions as well because I know we're coming up on times yoga I had a question for you how uh how did you find in terms of like finding the information the documentation around around the context propagation how how was that experience for you in terms of finding that information in the hotel Docs um it was pretty good actually uh so in the in the readme for this um repo which um oh which I hope that other people can help me uh test the documentation I would love for some folks to go and clone this repo and try and Spire all these Services up and make some calls and see if they can get it running locally um it was I it wasn't it was good um you know the the open Telemetry documentation has some some very good details around things that I glossed over today that I would I would really like to go into further detail around that I'm sure that anybody who watches this is probably going to start asking questions like well how does that actually work like there's a lot of magic under the hood but the open Telemetry documentation goes into a lot of detail around the things that I just waved my hands around like the tracers the trace exporters the context propagation the shape And format of spans um how these things all link together so I found I found it was pretty easy uh to find that and I also think that the the w3c documentation is also very good as well so I was able to kind of bring everything together pretty quickly like it didn't take me very long to build this reference implementation of these few applications um yeah open Telemetry also publishes a bunch of integration packages which lets you hook up to like node middleware or HTTP clients automatically so you can just have everything instrumented and doing the correct header insertion and things like that without really having to worry about doing it manually like like this demonstration noise yes that's a really good point so um uh one of the things that that I did as part of this uh this reference implementation was to do a very explicit implementation of these Concepts um we don't have time and I wanted to do that thing that you always see in a demo where somebody says do all this stuff and at the end of the demo and they say oh by the way you don't have to do anything you just do this other thing and it all gets handled for you there is a fast API instrument or um which will remove the need to do a lot of this explicit unpack um this explicit extraction and injection of the context um I didn't I didn't have time today to show that and I I kind of wanted to make it very clear to a developer who's learning these Concepts to walk through the code and see something very procedural that shows this for example there's a header and that header is very important and it is called a trace parent and it has a specification here's an example of teasing out that header in code the open Telemetry library has this thing where it can you know extract this context for you here's the line of code that does this when I make a call to another service I want to pass that along very explicitly so you know there was a lot of intention behind trying to make this application a bit more verbose even though it's very minimal to try to show somebody who's you know maybe new to this like what does this actually look like if you use the fast API instrumenter the good news is a lot of this gets handled for you um my recommendation would be for anyone who's getting started with microservices is to make sure that you include distributed tracing from the very very beginning and I would almost suggest that you spend a bit of time and implement this explicitly so that you understand what's happening so that other developers understand what's happening and once you solve the problem of observability then level up and start to leverage some of these other things that the open Telemetry gives us like Fast the fast API instrument or and these other things that that we get from the community um I feel I feel like that just kind of helps bake the concepts in for people and I I know that for me I'm a very tactile learner so like it helps me to see what's happening before I go and to start to do or start to let some libraries start to kind of handle that magic for me if that makes sense you know your mileage may vary but my recommendation would be to go ahead and do it explicitly it's a handful it's a few lines of code you can share it with people when you're doing code reviews you can explain to them what's happening it's not mysterious it's very explicit foreign have any questions for Doug thank you Doug for sharing that um one question from me is that um how does it look when you like so the obserability problem in production I suppose apart from this open Terminal tracing like part I suppose we also need to serve like logging and metrics and to find any difficulty like integrating like different part of obtibility um so the the last time I I spoke here um I I mentioned that the one of the the path that we took and had been taking that uplight has been to actually begin with the log signal and the reason is that um in terms of introducing these Concepts that these problems that open Telemetry solves these problems at the w3c helps us with solving is to begin with logging so that you because logging I think is very very familiar with most developers I think you know Junior intermediate developers are familiar with this concept of logging like a print statement and so what I've recommended and what we did at uplight when we started down this path was to start using the logging SDK even though it's newer than the the work for the signals of metrics and traces but to start with logging so that you can at least begin to practice including the packages and libraries into your code using open Telemetry to Omit that logging signal get that logging signal Landing in your your APM or whatever your observability platform is and once you make that connection of like I'm writing code I'm writing a statement that says logger.debug my message is landing in an APM it's structured it's it's it's being it's it's honoring the specification that the open Telemetry Community gives us then it's really easy to then um you know level up to add tracing and you get Trace law correlation for free and that's one of the things I would like to actually do with this this little reference implementation is to to add in some Trace log correlation so that people can see like how do I do the thing that I'm so familiar with doing like I like to send out a log I like to do a print statement like that's so we always do that all day every day and if you start with logging and you get the sdks into your repo and you have that information flow into your APM then adding the the layer of maturity around traces and the trace log correlation is almost free because you've already got everything packaged up into your application already so um you know that might not work for everybody to me that feels like a very natural way to evolve into using the specification using the sdks and and really kind of getting into observability Nirvana where you can walk up to your APM and say I have questions about the health and behavior of my services and I have a lot of them what's happening and you can get those answers if you do this Doug it sounds like you need to do a follow-up presentation on uh on logging you know I I would love to and I think that you know I would love some help from other people to take this this uh this repo and clone it or Fork it or just play with it and for if you know to help me test the documentation um some other things I would like to do is to go into the code itself and provide a bit more um kind of verbose commentary around what's happening again I think it's helpful to have very explicit implementation of these Concepts but for example I would I would really like to have you know some comments here that tell somebody hey when you call the extract method this is what it's doing for you because right now it you know it's magic it's just happening and that's awesome but I think for people to really understand what other Telemetry is doing and to understand what how all this works I think it would be helpful helpful to have in this reference implementation some pretty verbose comments and not the kind of thing you might want to put in your production code but for a reference implementation I think it would be helpful and I would love to do another one of these awesome um and you know I've been like looking through your repo as as you've been presenting and I really like this example it's it's uh it's simple but it's got enough complexity that it it illustrates what you're trying to um convey um so yeah I I think I I would love to at some point uh when I have some spare time to like poke around I I definitely encourage others to poke around as well maybe I I don't know uh as far as like I think it'd be cool to contribute this back to open Telemetry um although to be honest I I don't know if like other Hotel folks have uh have a better idea on the process around that because I I think I'm newer to the process but anyway um I think that yeah yeah and I you know I know that there are like there's a demo app and there's other reference implementations but one of one of the problems I was trying to solve here was how do I strip away every all the noise and give a developer with a modern operating system and docker the ability to get clone fire up these services and watch what's happening so they can really dig into these Concepts and understand how powerful they are in their Simplicity like it's pretty amazing like all we're doing is just you know sending a header and this these sdks are doing these wonderful things for us like it's it's pretty simple but it's unbelievably powerful and so the idea for this reference implementation was to try to just highlight that as best we could with as few lines of code as possible so that you know people can understand this and so that people can go and be successful with building this level of maturity in their observability in in their code yeah I totally agree and I think there's a lot of a lot of value in that like like you mentioned the open Telemetry demo app is is awesome because it shows like all of the things but there is definitely value in in simpler implementations like this one um so yeah um well on that note um I know we're a little bit over time um thank you everyone who was able to join us today um especially given that we uh started late and thanks Doug for uh uh you know working on the fly with our reduced time and for for lunch that's never uh never an easy task so definitely appreciate the time that you put into uh making this happen today um thanks everyone for joining us once again and um keep your eyes open for our next hotel in practice um I don't think we have one scheduled yet but we'll we'll post on on the various cncf slack channels for that um Rin do you have any additional upcoming announcements that uh folks should be aware of sure yeah so um first um there's an open Telemetry and practice Meetup if you came here through cncf um lightweight way to get notified whenever we have something and not have to look for the slack if you're not in the cncf slack and you want to talk further to um any of the hotel and practice folks Doug the audience um we're happy to add you um that information is in the chat and if you'll be at kubecon EU um several of us will be and we'd love to connect with you there will be a blog post on the open Telemetry blog on Monday with all of the activities and um yes I am happy to do a follow-up with Doug because of kubecon EU that will probably be in around the end of May and um we can figure out what format we want to do based on hopefully talking with you all in the slack thank you everybody [Music]

